<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.analyzer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.analyzer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from scapy.all import rdpcap, sniff, wrpcap, hexdump
from threading import Event
from layer.lorawan_phy import LoRa, MTypesEnum
from scapy.layers.inet import *

from src.crypto_tools import CryptoTool
from src.command_handler import CommandHandler
from src.session_manager import SessionManager, SessionParams
from datetime import datetime

pcap_file = &#34;/home/pentester/lorattack/session/data/clean/2024-04-14_14-03-10.pcap&#34;


class Analyzer(CommandHandler):
    &#34;&#34;&#34;Analyzer class for processing LoRaWAN data..

    This class provides functionalities to extract LoRaWAN messages from PCAP files and potentially perform further analysis on the captured data.
    &#34;&#34;&#34;

    def __init__(self):
        self.packets = []
        self.stop_event = Event()
        self.session_manager = SessionManager()
        self.crypto_tool = CryptoTool()

    def analyze_pcap(self, file_path):

        &#34;&#34;&#34;Analyzes a LoRaWAN PCAP file for LoRaWAN messages and performs basic analysis.

        This function reads a PCAP file containing captured network traffic and extracts packets containing LoRaWAN messages. It iterates through each packet, printing a summary and attempting to decode it using the LoRa layer. Decoded LoRaWAN messages are analyzed based on their message type (Join Request, Join Accept, etc.). If session keys are available in the `SessionManager`, the function attempts to decrypt the payload of uplink messages.

        Args:
            file_path (str): The path to the PCAP file containing LoRaWAN messages.

        Returns:
            None
        &#34;&#34;&#34;
        packets = rdpcap(file_path)

        print(f&#34;Total packets in pcap: {len(packets)}&#34;)

        # Iterate through each packet and print a summary
        for packet in packets:
            print(packet.summary())

            if packet.haslayer(UDP):
                try:
                    decoded = LoRa(packet[UDP].load)
                    self.analyze_lora_packet(decoded, packet)

                    print(repr(decoded))
                except:
                    print(&#34;Packet could not be decoded&#34;)

    def get_packet_sequence_from_pcap(self, path):
        &#34;&#34;&#34;Extracts a sequence of LoRaWAN packets from a PCAP file.

         Parses the provided PCAP file and extracts packets containing LoRaWAN messages. It returns a list of the extracted LoRaWAN message payloads in hexadecimal format.

         Args:
             pcap_path (str): The path to the PCAP file containing LoRaWAN messages.

         Returns:
             list[str]: A list of LoRaWAN message payloads extracted from the PCAP file, or an empty list if no LoRaWAN messages are found.

         Raises:
             ValueError: If the PCAP file cannot be opened or processed.
         &#34;&#34;&#34;
        packets = rdpcap(path)
        indexes = self.session_manager.read_sequence_file()
        payloads = []
        for i in indexes:
            payloads.append(packets[i][UDP].load.hex())

        return payloads

    def analyze_lora_packet(self, packet, raw_packet):
        &#34;&#34;&#34;Analyzes a decoded LoRaWAN message based on its message type.

        This function takes a decoded LoRaWAN message object and the raw packet containing the message. It analyzes the message type (Join Request, Join Accept, etc.) and performs actions based on the type:

        - For Join Request messages, it updates session parameters in the `SessionManager` with extracted values.
        - For Join Accept messages, it attempts to decrypt the message if the AppKey is available. If successful, it derives session keys and updates the `SessionManager` with them.
        - For uplink data messages (confirmed or unconfirmed), it attempts to decrypt the payload if the AppSKey is available. The decrypted payload is printed in hexadecimal and ASCII format.

        Args:
            packet (LoRa): The decoded LoRaWAN message object.
            raw_packet (Packet): The raw packet containing the LoRaWAN message.

        Returns:
            None
        &#34;&#34;&#34;
        if packet.MType == MTypesEnum.join_request.bit_value:
            print(&#39;Found Join Request&#39;)
            self.session_manager.update_session_value(SessionParams.JoinRequest_AppEUI,
                                                      packet.Join_Request_Field[0].AppEUI.hex())
            self.session_manager.update_session_value(SessionParams.JoinRequest_DevEUI,
                                                      packet.Join_Request_Field[0].DevEUI.hex())
            self.session_manager.update_session_value(SessionParams.JoinRequest_JoinEUI,
                                                      packet.Join_Request_Field[0].AppEUI.hex())
            self.session_manager.update_session_value(SessionParams.JoinRequest_DevNonce,
                                                      format(packet.Join_Request_Field[0].DevNonce, &#39;02x&#39;))
        elif packet.MType == MTypesEnum.join_accept.bit_value:
            print(&#39;Found Join Accept&#39;)
            if self.session_manager.get_session_value(SessionParams.AppKey) is not None:
                decrypted_join_accept = CryptoTool.decrypt_join_accept(raw_packet[UDP].load, bytes(
                    self.session_manager.get_session_value(SessionParams.AppKey)))
                decoded_join_accept = LoRa(decrypted_join_accept)
                print(&#39;Successfuly decrypted Join Accept messages&#39;)
                print(&#39;Computing session keys&#39;)
                self.session_manager.update_session_value(SessionParams.JoinAccept_AppNonce,
                                                          format(decoded_join_accept.Join_Accept_Field[0].JoinAppNonce,
                                                                 &#39;02x&#39;))
                self.session_manager.update_session_value(SessionParams.JoinAccept_JoinNonce,
                                                          format(decoded_join_accept.Join_Accept_Field[0].JoinAppNonce,
                                                                 &#39;02x&#39;))
                self.session_manager.update_session_value(SessionParams.JoinAccept_DevAddr,
                                                          decoded_join_accept.Join_Request_Field[0].DevAddr.hex())
                self.session_manager.update_session_value(SessionParams.JoinAccept_NetID,
                                                          decoded_join_accept.Join_Request_Field[0].NetID.hex())

                nwk_skey, app_skey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey = CryptoTool.derive_session_keys(
                    self.session_manager.get_session_value(SessionParams.AppKey),
                    self.session_manager.get_session_value(SessionParams.NwkKey),
                    self.session_manager.get_session_value(SessionParams.JoinRequest_JoinEUI),
                    self.session_manager.get_session_value(SessionParams.JoinAccept_AppNonce),
                    self.session_manager.get_session_value(SessionParams.JoinAccept_NetID),
                    self.session_manager.get_session_value(SessionParams.JoinRequest_DevNonce))

                self.session_manager.update_session_value(SessionParams.NwkSKey, nwk_skey)
                self.session_manager.update_session_value(SessionParams.AppSKey, app_skey)
                self.session_manager.update_session_value(SessionParams.FNwkSIntKey, FNwkSIntKey)
                self.session_manager.update_session_value(SessionParams.SNwkSIntKey, SNwkSIntKey)
                self.session_manager.update_session_value(SessionParams.NwkSEncKey, NwkSEncKey)
        elif packet.MType == MTypesEnum.unconfirmed_data_up.bit_value:
            print(&#39;Found Unconfirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.ULDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
        elif packet.MType == MTypesEnum.confirmed_data_up.bit_value:
            print(&#39;Found Confirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.ULDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
        elif packet.MType == MTypesEnum.unconfirmed_data_down.bit_value:
            print(&#39;Found Unconfirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.DLDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
        elif packet.MType == MTypesEnum.confirmed_data_down.bit_value:
            print(&#39;Found Confirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.DLDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))

    def packet_callback(self, packet):
        &#34;&#34;&#34;Callback function for live sniffing of packets.

        This function is called for each captured packet during live sniffing with `sniff`. It checks if the packet is a UDP packet with the LoRaWAN port (40868) and attempts to:

        - Append the packet to the internal list (`packets`).
        - Decode the LoRaWAN message within the packet.
        - Analyze the decoded message using `analyze_lora_packet`.

        If the decoding fails, a message is printed.

        Args:
            packet (Packet): The captured network packet.

        Returns:
            None
        &#34;&#34;&#34;
        if packet.haslayer(UDP) and packet[UDP].dport == 40868:
            try:
                self.packets.append(packet)
                decoded = LoRa(packet[UDP].load)
                print(repr(decoded))
                self.analyze_lora_packet(decoded, packet)
            except:
                print(&#34;Packet could not be decoded&#34;)

    def stop_filter_func(self, packet):
        &#34;&#34;&#34;Filter function used during live sniffing to stop capturing packets.

        This function is used as a filter with `sniff` during live sniffing. It simply checks if the `stop_event` flag is set, indicating the user wants to stop capturing packets.

        Args:
            packet (Packet): The captured network packet (ignored).

        Returns:
            bool: True if the `stop_event` is set, False otherwise.
        &#34;&#34;&#34;
        return self.stop_event.is_set()

    def live_sniffing(self):
        &#34;&#34;&#34;Starts live sniffing for LoRaWAN packets on the loopback interface.

        This function starts capturing packets on the loopback interface (lo) using `sniff` and the `packet_callback` function. Once capturing is stopped (using `stop_event`), it stores the captured packets to a PCAP file and optionally converts it to a Wireshark-readable format using the `bittwiste` tool.

        Returns:
            None
        &#34;&#34;&#34;
        print(&#39;sniffing...&#39;)
        sniff(iface=&#34;lo&#34;, prn=self.packet_callback, stop_filter=self.stop_filter_func)
        print(&#39;Storing pcap to file&#39;)
        current_time = datetime.now().strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
        filename = f&#34;{current_time}.pcap&#34;
        path = self.session_manager.sessions_dir + &#39;/&#39; + self.session_manager.get_current_session_name() + &#39;/&#39;
        wrpcap(path + filename, self.packets)
        print(f&#34;Saved {len(self.packets)} packets to {filename}&#34;)
        command = [&#39;bittwiste&#39;, &#39;-I&#39;, path + filename, &#39;-O&#39;, path + &#39;wireshark_&#39; + filename, &#39;-M&#39;, &#39;147&#39;, &#39;-D&#39;, &#39;1-42&#39;]
        self.execute_command(command)

    def terminate_sniffer(self):
        &#34;&#34;&#34;Sets a flag to stop live sniffing.

        This function sets the `stop_event` flag, which is used by the `stop_filter_func` to terminate live sniffing with `sniff`.

        Returns: None

        self.stop_event.set()
        &#34;&#34;&#34;


if __name__ == &#34;__main__&#34;:
    a = Analyzer()
    a.analyze_pcap(pcap_file)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.analyzer.Analyzer"><code class="flex name class">
<span>class <span class="ident">Analyzer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Analyzer class for processing LoRaWAN data..</p>
<p>This class provides functionalities to extract LoRaWAN messages from PCAP files and potentially perform further analysis on the captured data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Analyzer(CommandHandler):
    &#34;&#34;&#34;Analyzer class for processing LoRaWAN data..

    This class provides functionalities to extract LoRaWAN messages from PCAP files and potentially perform further analysis on the captured data.
    &#34;&#34;&#34;

    def __init__(self):
        self.packets = []
        self.stop_event = Event()
        self.session_manager = SessionManager()
        self.crypto_tool = CryptoTool()

    def analyze_pcap(self, file_path):

        &#34;&#34;&#34;Analyzes a LoRaWAN PCAP file for LoRaWAN messages and performs basic analysis.

        This function reads a PCAP file containing captured network traffic and extracts packets containing LoRaWAN messages. It iterates through each packet, printing a summary and attempting to decode it using the LoRa layer. Decoded LoRaWAN messages are analyzed based on their message type (Join Request, Join Accept, etc.). If session keys are available in the `SessionManager`, the function attempts to decrypt the payload of uplink messages.

        Args:
            file_path (str): The path to the PCAP file containing LoRaWAN messages.

        Returns:
            None
        &#34;&#34;&#34;
        packets = rdpcap(file_path)

        print(f&#34;Total packets in pcap: {len(packets)}&#34;)

        # Iterate through each packet and print a summary
        for packet in packets:
            print(packet.summary())

            if packet.haslayer(UDP):
                try:
                    decoded = LoRa(packet[UDP].load)
                    self.analyze_lora_packet(decoded, packet)

                    print(repr(decoded))
                except:
                    print(&#34;Packet could not be decoded&#34;)

    def get_packet_sequence_from_pcap(self, path):
        &#34;&#34;&#34;Extracts a sequence of LoRaWAN packets from a PCAP file.

         Parses the provided PCAP file and extracts packets containing LoRaWAN messages. It returns a list of the extracted LoRaWAN message payloads in hexadecimal format.

         Args:
             pcap_path (str): The path to the PCAP file containing LoRaWAN messages.

         Returns:
             list[str]: A list of LoRaWAN message payloads extracted from the PCAP file, or an empty list if no LoRaWAN messages are found.

         Raises:
             ValueError: If the PCAP file cannot be opened or processed.
         &#34;&#34;&#34;
        packets = rdpcap(path)
        indexes = self.session_manager.read_sequence_file()
        payloads = []
        for i in indexes:
            payloads.append(packets[i][UDP].load.hex())

        return payloads

    def analyze_lora_packet(self, packet, raw_packet):
        &#34;&#34;&#34;Analyzes a decoded LoRaWAN message based on its message type.

        This function takes a decoded LoRaWAN message object and the raw packet containing the message. It analyzes the message type (Join Request, Join Accept, etc.) and performs actions based on the type:

        - For Join Request messages, it updates session parameters in the `SessionManager` with extracted values.
        - For Join Accept messages, it attempts to decrypt the message if the AppKey is available. If successful, it derives session keys and updates the `SessionManager` with them.
        - For uplink data messages (confirmed or unconfirmed), it attempts to decrypt the payload if the AppSKey is available. The decrypted payload is printed in hexadecimal and ASCII format.

        Args:
            packet (LoRa): The decoded LoRaWAN message object.
            raw_packet (Packet): The raw packet containing the LoRaWAN message.

        Returns:
            None
        &#34;&#34;&#34;
        if packet.MType == MTypesEnum.join_request.bit_value:
            print(&#39;Found Join Request&#39;)
            self.session_manager.update_session_value(SessionParams.JoinRequest_AppEUI,
                                                      packet.Join_Request_Field[0].AppEUI.hex())
            self.session_manager.update_session_value(SessionParams.JoinRequest_DevEUI,
                                                      packet.Join_Request_Field[0].DevEUI.hex())
            self.session_manager.update_session_value(SessionParams.JoinRequest_JoinEUI,
                                                      packet.Join_Request_Field[0].AppEUI.hex())
            self.session_manager.update_session_value(SessionParams.JoinRequest_DevNonce,
                                                      format(packet.Join_Request_Field[0].DevNonce, &#39;02x&#39;))
        elif packet.MType == MTypesEnum.join_accept.bit_value:
            print(&#39;Found Join Accept&#39;)
            if self.session_manager.get_session_value(SessionParams.AppKey) is not None:
                decrypted_join_accept = CryptoTool.decrypt_join_accept(raw_packet[UDP].load, bytes(
                    self.session_manager.get_session_value(SessionParams.AppKey)))
                decoded_join_accept = LoRa(decrypted_join_accept)
                print(&#39;Successfuly decrypted Join Accept messages&#39;)
                print(&#39;Computing session keys&#39;)
                self.session_manager.update_session_value(SessionParams.JoinAccept_AppNonce,
                                                          format(decoded_join_accept.Join_Accept_Field[0].JoinAppNonce,
                                                                 &#39;02x&#39;))
                self.session_manager.update_session_value(SessionParams.JoinAccept_JoinNonce,
                                                          format(decoded_join_accept.Join_Accept_Field[0].JoinAppNonce,
                                                                 &#39;02x&#39;))
                self.session_manager.update_session_value(SessionParams.JoinAccept_DevAddr,
                                                          decoded_join_accept.Join_Request_Field[0].DevAddr.hex())
                self.session_manager.update_session_value(SessionParams.JoinAccept_NetID,
                                                          decoded_join_accept.Join_Request_Field[0].NetID.hex())

                nwk_skey, app_skey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey = CryptoTool.derive_session_keys(
                    self.session_manager.get_session_value(SessionParams.AppKey),
                    self.session_manager.get_session_value(SessionParams.NwkKey),
                    self.session_manager.get_session_value(SessionParams.JoinRequest_JoinEUI),
                    self.session_manager.get_session_value(SessionParams.JoinAccept_AppNonce),
                    self.session_manager.get_session_value(SessionParams.JoinAccept_NetID),
                    self.session_manager.get_session_value(SessionParams.JoinRequest_DevNonce))

                self.session_manager.update_session_value(SessionParams.NwkSKey, nwk_skey)
                self.session_manager.update_session_value(SessionParams.AppSKey, app_skey)
                self.session_manager.update_session_value(SessionParams.FNwkSIntKey, FNwkSIntKey)
                self.session_manager.update_session_value(SessionParams.SNwkSIntKey, SNwkSIntKey)
                self.session_manager.update_session_value(SessionParams.NwkSEncKey, NwkSEncKey)
        elif packet.MType == MTypesEnum.unconfirmed_data_up.bit_value:
            print(&#39;Found Unconfirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.ULDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
        elif packet.MType == MTypesEnum.confirmed_data_up.bit_value:
            print(&#39;Found Confirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.ULDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
        elif packet.MType == MTypesEnum.unconfirmed_data_down.bit_value:
            print(&#39;Found Unconfirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.DLDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
        elif packet.MType == MTypesEnum.confirmed_data_down.bit_value:
            print(&#39;Found Confirmed Data Up&#39;)
            if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
                print(&#39;Decrypting payload&#39;)
                session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
                pt = self.crypto_tool.FRMPayload_decrypt(packet.DLDataPayload.hex(), packet.FCnt, session_key,
                                                         self.session_manager.get_session_value(
                                                             SessionParams.JoinAccept_DevAddr), 0)
                print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))

    def packet_callback(self, packet):
        &#34;&#34;&#34;Callback function for live sniffing of packets.

        This function is called for each captured packet during live sniffing with `sniff`. It checks if the packet is a UDP packet with the LoRaWAN port (40868) and attempts to:

        - Append the packet to the internal list (`packets`).
        - Decode the LoRaWAN message within the packet.
        - Analyze the decoded message using `analyze_lora_packet`.

        If the decoding fails, a message is printed.

        Args:
            packet (Packet): The captured network packet.

        Returns:
            None
        &#34;&#34;&#34;
        if packet.haslayer(UDP) and packet[UDP].dport == 40868:
            try:
                self.packets.append(packet)
                decoded = LoRa(packet[UDP].load)
                print(repr(decoded))
                self.analyze_lora_packet(decoded, packet)
            except:
                print(&#34;Packet could not be decoded&#34;)

    def stop_filter_func(self, packet):
        &#34;&#34;&#34;Filter function used during live sniffing to stop capturing packets.

        This function is used as a filter with `sniff` during live sniffing. It simply checks if the `stop_event` flag is set, indicating the user wants to stop capturing packets.

        Args:
            packet (Packet): The captured network packet (ignored).

        Returns:
            bool: True if the `stop_event` is set, False otherwise.
        &#34;&#34;&#34;
        return self.stop_event.is_set()

    def live_sniffing(self):
        &#34;&#34;&#34;Starts live sniffing for LoRaWAN packets on the loopback interface.

        This function starts capturing packets on the loopback interface (lo) using `sniff` and the `packet_callback` function. Once capturing is stopped (using `stop_event`), it stores the captured packets to a PCAP file and optionally converts it to a Wireshark-readable format using the `bittwiste` tool.

        Returns:
            None
        &#34;&#34;&#34;
        print(&#39;sniffing...&#39;)
        sniff(iface=&#34;lo&#34;, prn=self.packet_callback, stop_filter=self.stop_filter_func)
        print(&#39;Storing pcap to file&#39;)
        current_time = datetime.now().strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
        filename = f&#34;{current_time}.pcap&#34;
        path = self.session_manager.sessions_dir + &#39;/&#39; + self.session_manager.get_current_session_name() + &#39;/&#39;
        wrpcap(path + filename, self.packets)
        print(f&#34;Saved {len(self.packets)} packets to {filename}&#34;)
        command = [&#39;bittwiste&#39;, &#39;-I&#39;, path + filename, &#39;-O&#39;, path + &#39;wireshark_&#39; + filename, &#39;-M&#39;, &#39;147&#39;, &#39;-D&#39;, &#39;1-42&#39;]
        self.execute_command(command)

    def terminate_sniffer(self):
        &#34;&#34;&#34;Sets a flag to stop live sniffing.

        This function sets the `stop_event` flag, which is used by the `stop_filter_func` to terminate live sniffing with `sniff`.

        Returns: None

        self.stop_event.set()
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.command_handler.CommandHandler" href="command_handler.html#src.command_handler.CommandHandler">CommandHandler</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.analyzer.Analyzer.analyze_lora_packet"><code class="name flex">
<span>def <span class="ident">analyze_lora_packet</span></span>(<span>self, packet, raw_packet)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyzes a decoded LoRaWAN message based on its message type.</p>
<p>This function takes a decoded LoRaWAN message object and the raw packet containing the message. It analyzes the message type (Join Request, Join Accept, etc.) and performs actions based on the type:</p>
<ul>
<li>For Join Request messages, it updates session parameters in the <code>SessionManager</code> with extracted values.</li>
<li>For Join Accept messages, it attempts to decrypt the message if the AppKey is available. If successful, it derives session keys and updates the <code>SessionManager</code> with them.</li>
<li>For uplink data messages (confirmed or unconfirmed), it attempts to decrypt the payload if the AppSKey is available. The decrypted payload is printed in hexadecimal and ASCII format.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packet</code></strong> :&ensp;<code>LoRa</code></dt>
<dd>The decoded LoRaWAN message object.</dd>
<dt><strong><code>raw_packet</code></strong> :&ensp;<code>Packet</code></dt>
<dd>The raw packet containing the LoRaWAN message.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_lora_packet(self, packet, raw_packet):
    &#34;&#34;&#34;Analyzes a decoded LoRaWAN message based on its message type.

    This function takes a decoded LoRaWAN message object and the raw packet containing the message. It analyzes the message type (Join Request, Join Accept, etc.) and performs actions based on the type:

    - For Join Request messages, it updates session parameters in the `SessionManager` with extracted values.
    - For Join Accept messages, it attempts to decrypt the message if the AppKey is available. If successful, it derives session keys and updates the `SessionManager` with them.
    - For uplink data messages (confirmed or unconfirmed), it attempts to decrypt the payload if the AppSKey is available. The decrypted payload is printed in hexadecimal and ASCII format.

    Args:
        packet (LoRa): The decoded LoRaWAN message object.
        raw_packet (Packet): The raw packet containing the LoRaWAN message.

    Returns:
        None
    &#34;&#34;&#34;
    if packet.MType == MTypesEnum.join_request.bit_value:
        print(&#39;Found Join Request&#39;)
        self.session_manager.update_session_value(SessionParams.JoinRequest_AppEUI,
                                                  packet.Join_Request_Field[0].AppEUI.hex())
        self.session_manager.update_session_value(SessionParams.JoinRequest_DevEUI,
                                                  packet.Join_Request_Field[0].DevEUI.hex())
        self.session_manager.update_session_value(SessionParams.JoinRequest_JoinEUI,
                                                  packet.Join_Request_Field[0].AppEUI.hex())
        self.session_manager.update_session_value(SessionParams.JoinRequest_DevNonce,
                                                  format(packet.Join_Request_Field[0].DevNonce, &#39;02x&#39;))
    elif packet.MType == MTypesEnum.join_accept.bit_value:
        print(&#39;Found Join Accept&#39;)
        if self.session_manager.get_session_value(SessionParams.AppKey) is not None:
            decrypted_join_accept = CryptoTool.decrypt_join_accept(raw_packet[UDP].load, bytes(
                self.session_manager.get_session_value(SessionParams.AppKey)))
            decoded_join_accept = LoRa(decrypted_join_accept)
            print(&#39;Successfuly decrypted Join Accept messages&#39;)
            print(&#39;Computing session keys&#39;)
            self.session_manager.update_session_value(SessionParams.JoinAccept_AppNonce,
                                                      format(decoded_join_accept.Join_Accept_Field[0].JoinAppNonce,
                                                             &#39;02x&#39;))
            self.session_manager.update_session_value(SessionParams.JoinAccept_JoinNonce,
                                                      format(decoded_join_accept.Join_Accept_Field[0].JoinAppNonce,
                                                             &#39;02x&#39;))
            self.session_manager.update_session_value(SessionParams.JoinAccept_DevAddr,
                                                      decoded_join_accept.Join_Request_Field[0].DevAddr.hex())
            self.session_manager.update_session_value(SessionParams.JoinAccept_NetID,
                                                      decoded_join_accept.Join_Request_Field[0].NetID.hex())

            nwk_skey, app_skey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey = CryptoTool.derive_session_keys(
                self.session_manager.get_session_value(SessionParams.AppKey),
                self.session_manager.get_session_value(SessionParams.NwkKey),
                self.session_manager.get_session_value(SessionParams.JoinRequest_JoinEUI),
                self.session_manager.get_session_value(SessionParams.JoinAccept_AppNonce),
                self.session_manager.get_session_value(SessionParams.JoinAccept_NetID),
                self.session_manager.get_session_value(SessionParams.JoinRequest_DevNonce))

            self.session_manager.update_session_value(SessionParams.NwkSKey, nwk_skey)
            self.session_manager.update_session_value(SessionParams.AppSKey, app_skey)
            self.session_manager.update_session_value(SessionParams.FNwkSIntKey, FNwkSIntKey)
            self.session_manager.update_session_value(SessionParams.SNwkSIntKey, SNwkSIntKey)
            self.session_manager.update_session_value(SessionParams.NwkSEncKey, NwkSEncKey)
    elif packet.MType == MTypesEnum.unconfirmed_data_up.bit_value:
        print(&#39;Found Unconfirmed Data Up&#39;)
        if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
            print(&#39;Decrypting payload&#39;)
            session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
            pt = self.crypto_tool.FRMPayload_decrypt(packet.ULDataPayload.hex(), packet.FCnt, session_key,
                                                     self.session_manager.get_session_value(
                                                         SessionParams.JoinAccept_DevAddr), 0)
            print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
    elif packet.MType == MTypesEnum.confirmed_data_up.bit_value:
        print(&#39;Found Confirmed Data Up&#39;)
        if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
            print(&#39;Decrypting payload&#39;)
            session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
            pt = self.crypto_tool.FRMPayload_decrypt(packet.ULDataPayload.hex(), packet.FCnt, session_key,
                                                     self.session_manager.get_session_value(
                                                         SessionParams.JoinAccept_DevAddr), 0)
            print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
    elif packet.MType == MTypesEnum.unconfirmed_data_down.bit_value:
        print(&#39;Found Unconfirmed Data Up&#39;)
        if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
            print(&#39;Decrypting payload&#39;)
            session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
            pt = self.crypto_tool.FRMPayload_decrypt(packet.DLDataPayload.hex(), packet.FCnt, session_key,
                                                     self.session_manager.get_session_value(
                                                         SessionParams.JoinAccept_DevAddr), 0)
            print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))
    elif packet.MType == MTypesEnum.confirmed_data_down.bit_value:
        print(&#39;Found Confirmed Data Up&#39;)
        if self.session_manager.get_session_value(SessionParams.AppSKey) is not None:
            print(&#39;Decrypting payload&#39;)
            session_key = self.session_manager.get_session_value(SessionParams.AppSKey)
            pt = self.crypto_tool.FRMPayload_decrypt(packet.DLDataPayload.hex(), packet.FCnt, session_key,
                                                     self.session_manager.get_session_value(
                                                         SessionParams.JoinAccept_DevAddr), 0)
            print(bytes(pt).hex(), bytes(pt).decode(&#39;iso-8859-1&#39;))</code></pre>
</details>
</dd>
<dt id="src.analyzer.Analyzer.analyze_pcap"><code class="name flex">
<span>def <span class="ident">analyze_pcap</span></span>(<span>self, file_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Analyzes a LoRaWAN PCAP file for LoRaWAN messages and performs basic analysis.</p>
<p>This function reads a PCAP file containing captured network traffic and extracts packets containing LoRaWAN messages. It iterates through each packet, printing a summary and attempting to decode it using the LoRa layer. Decoded LoRaWAN messages are analyzed based on their message type (Join Request, Join Accept, etc.). If session keys are available in the <code>SessionManager</code>, the function attempts to decrypt the payload of uplink messages.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the PCAP file containing LoRaWAN messages.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_pcap(self, file_path):

    &#34;&#34;&#34;Analyzes a LoRaWAN PCAP file for LoRaWAN messages and performs basic analysis.

    This function reads a PCAP file containing captured network traffic and extracts packets containing LoRaWAN messages. It iterates through each packet, printing a summary and attempting to decode it using the LoRa layer. Decoded LoRaWAN messages are analyzed based on their message type (Join Request, Join Accept, etc.). If session keys are available in the `SessionManager`, the function attempts to decrypt the payload of uplink messages.

    Args:
        file_path (str): The path to the PCAP file containing LoRaWAN messages.

    Returns:
        None
    &#34;&#34;&#34;
    packets = rdpcap(file_path)

    print(f&#34;Total packets in pcap: {len(packets)}&#34;)

    # Iterate through each packet and print a summary
    for packet in packets:
        print(packet.summary())

        if packet.haslayer(UDP):
            try:
                decoded = LoRa(packet[UDP].load)
                self.analyze_lora_packet(decoded, packet)

                print(repr(decoded))
            except:
                print(&#34;Packet could not be decoded&#34;)</code></pre>
</details>
</dd>
<dt id="src.analyzer.Analyzer.get_packet_sequence_from_pcap"><code class="name flex">
<span>def <span class="ident">get_packet_sequence_from_pcap</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Extracts a sequence of LoRaWAN packets from a PCAP file.</p>
<p>Parses the provided PCAP file and extracts packets containing LoRaWAN messages. It returns a list of the extracted LoRaWAN message payloads in hexadecimal format.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pcap_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the PCAP file containing LoRaWAN messages.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[str]</code></dt>
<dd>A list of LoRaWAN message payloads extracted from the PCAP file, or an empty list if no LoRaWAN messages are found.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the PCAP file cannot be opened or processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_packet_sequence_from_pcap(self, path):
    &#34;&#34;&#34;Extracts a sequence of LoRaWAN packets from a PCAP file.

     Parses the provided PCAP file and extracts packets containing LoRaWAN messages. It returns a list of the extracted LoRaWAN message payloads in hexadecimal format.

     Args:
         pcap_path (str): The path to the PCAP file containing LoRaWAN messages.

     Returns:
         list[str]: A list of LoRaWAN message payloads extracted from the PCAP file, or an empty list if no LoRaWAN messages are found.

     Raises:
         ValueError: If the PCAP file cannot be opened or processed.
     &#34;&#34;&#34;
    packets = rdpcap(path)
    indexes = self.session_manager.read_sequence_file()
    payloads = []
    for i in indexes:
        payloads.append(packets[i][UDP].load.hex())

    return payloads</code></pre>
</details>
</dd>
<dt id="src.analyzer.Analyzer.live_sniffing"><code class="name flex">
<span>def <span class="ident">live_sniffing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts live sniffing for LoRaWAN packets on the loopback interface.</p>
<p>This function starts capturing packets on the loopback interface (lo) using <code>sniff</code> and the <code>packet_callback</code> function. Once capturing is stopped (using <code>stop_event</code>), it stores the captured packets to a PCAP file and optionally converts it to a Wireshark-readable format using the <code>bittwiste</code> tool.</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def live_sniffing(self):
    &#34;&#34;&#34;Starts live sniffing for LoRaWAN packets on the loopback interface.

    This function starts capturing packets on the loopback interface (lo) using `sniff` and the `packet_callback` function. Once capturing is stopped (using `stop_event`), it stores the captured packets to a PCAP file and optionally converts it to a Wireshark-readable format using the `bittwiste` tool.

    Returns:
        None
    &#34;&#34;&#34;
    print(&#39;sniffing...&#39;)
    sniff(iface=&#34;lo&#34;, prn=self.packet_callback, stop_filter=self.stop_filter_func)
    print(&#39;Storing pcap to file&#39;)
    current_time = datetime.now().strftime(&#34;%Y-%m-%d_%H-%M-%S&#34;)
    filename = f&#34;{current_time}.pcap&#34;
    path = self.session_manager.sessions_dir + &#39;/&#39; + self.session_manager.get_current_session_name() + &#39;/&#39;
    wrpcap(path + filename, self.packets)
    print(f&#34;Saved {len(self.packets)} packets to {filename}&#34;)
    command = [&#39;bittwiste&#39;, &#39;-I&#39;, path + filename, &#39;-O&#39;, path + &#39;wireshark_&#39; + filename, &#39;-M&#39;, &#39;147&#39;, &#39;-D&#39;, &#39;1-42&#39;]
    self.execute_command(command)</code></pre>
</details>
</dd>
<dt id="src.analyzer.Analyzer.packet_callback"><code class="name flex">
<span>def <span class="ident">packet_callback</span></span>(<span>self, packet)</span>
</code></dt>
<dd>
<div class="desc"><p>Callback function for live sniffing of packets.</p>
<p>This function is called for each captured packet during live sniffing with <code>sniff</code>. It checks if the packet is a UDP packet with the LoRaWAN port (40868) and attempts to:</p>
<ul>
<li>Append the packet to the internal list (<code>packets</code>).</li>
<li>Decode the LoRaWAN message within the packet.</li>
<li>Analyze the decoded message using <code>analyze_lora_packet</code>.</li>
</ul>
<p>If the decoding fails, a message is printed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packet</code></strong> :&ensp;<code>Packet</code></dt>
<dd>The captured network packet.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def packet_callback(self, packet):
    &#34;&#34;&#34;Callback function for live sniffing of packets.

    This function is called for each captured packet during live sniffing with `sniff`. It checks if the packet is a UDP packet with the LoRaWAN port (40868) and attempts to:

    - Append the packet to the internal list (`packets`).
    - Decode the LoRaWAN message within the packet.
    - Analyze the decoded message using `analyze_lora_packet`.

    If the decoding fails, a message is printed.

    Args:
        packet (Packet): The captured network packet.

    Returns:
        None
    &#34;&#34;&#34;
    if packet.haslayer(UDP) and packet[UDP].dport == 40868:
        try:
            self.packets.append(packet)
            decoded = LoRa(packet[UDP].load)
            print(repr(decoded))
            self.analyze_lora_packet(decoded, packet)
        except:
            print(&#34;Packet could not be decoded&#34;)</code></pre>
</details>
</dd>
<dt id="src.analyzer.Analyzer.stop_filter_func"><code class="name flex">
<span>def <span class="ident">stop_filter_func</span></span>(<span>self, packet)</span>
</code></dt>
<dd>
<div class="desc"><p>Filter function used during live sniffing to stop capturing packets.</p>
<p>This function is used as a filter with <code>sniff</code> during live sniffing. It simply checks if the <code>stop_event</code> flag is set, indicating the user wants to stop capturing packets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packet</code></strong> :&ensp;<code>Packet</code></dt>
<dd>The captured network packet (ignored).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the <code>stop_event</code> is set, False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_filter_func(self, packet):
    &#34;&#34;&#34;Filter function used during live sniffing to stop capturing packets.

    This function is used as a filter with `sniff` during live sniffing. It simply checks if the `stop_event` flag is set, indicating the user wants to stop capturing packets.

    Args:
        packet (Packet): The captured network packet (ignored).

    Returns:
        bool: True if the `stop_event` is set, False otherwise.
    &#34;&#34;&#34;
    return self.stop_event.is_set()</code></pre>
</details>
</dd>
<dt id="src.analyzer.Analyzer.terminate_sniffer"><code class="name flex">
<span>def <span class="ident">terminate_sniffer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a flag to stop live sniffing.</p>
<p>This function sets the <code>stop_event</code> flag, which is used by the <code>stop_filter_func</code> to terminate live sniffing with <code>sniff</code>.</p>
<p>Returns: None</p>
<p>self.stop_event.set()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminate_sniffer(self):
    &#34;&#34;&#34;Sets a flag to stop live sniffing.

    This function sets the `stop_event` flag, which is used by the `stop_filter_func` to terminate live sniffing with `sniff`.

    Returns: None

    self.stop_event.set()
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.command_handler.CommandHandler" href="command_handler.html#src.command_handler.CommandHandler">CommandHandler</a></b></code>:
<ul class="hlist">
<li><code><a title="src.command_handler.CommandHandler.execute_command" href="command_handler.html#src.command_handler.CommandHandler.execute_command">execute_command</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.analyzer.Analyzer" href="#src.analyzer.Analyzer">Analyzer</a></code></h4>
<ul class="">
<li><code><a title="src.analyzer.Analyzer.analyze_lora_packet" href="#src.analyzer.Analyzer.analyze_lora_packet">analyze_lora_packet</a></code></li>
<li><code><a title="src.analyzer.Analyzer.analyze_pcap" href="#src.analyzer.Analyzer.analyze_pcap">analyze_pcap</a></code></li>
<li><code><a title="src.analyzer.Analyzer.get_packet_sequence_from_pcap" href="#src.analyzer.Analyzer.get_packet_sequence_from_pcap">get_packet_sequence_from_pcap</a></code></li>
<li><code><a title="src.analyzer.Analyzer.live_sniffing" href="#src.analyzer.Analyzer.live_sniffing">live_sniffing</a></code></li>
<li><code><a title="src.analyzer.Analyzer.packet_callback" href="#src.analyzer.Analyzer.packet_callback">packet_callback</a></code></li>
<li><code><a title="src.analyzer.Analyzer.stop_filter_func" href="#src.analyzer.Analyzer.stop_filter_func">stop_filter_func</a></code></li>
<li><code><a title="src.analyzer.Analyzer.terminate_sniffer" href="#src.analyzer.Analyzer.terminate_sniffer">terminate_sniffer</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>