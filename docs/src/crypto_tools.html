<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.crypto_tools API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.crypto_tools</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys

from Crypto.Cipher import AES
from Crypto.Hash import CMAC
import binascii
from binascii import unhexlify

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

class CryptoTool():
    &#34;&#34;&#34;Cryptographic toolset for LoRaWAN security operations.

    This class provides functionalities for encryption, decryption, key derivation, and message integrity checking (MIC) used in LoRaWAN communication. It supports operations on Join Accept messages, session key derivation, and FRMPayload encryption/decryption for both uplink and downlink directions.
    &#34;&#34;&#34;
    def decrypt_join_accept(self, packet, appkey):
        &#34;&#34;&#34;Decrypts a Join Accept message using the provided AppKey.

        This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It removes the checksum and decrypts the payload using AES in ECB mode with the AppKey.

        Args:
            packet (bytes): The LoRaWAN Join Accept message to decrypt.
            appkey (bytes): The AppKey used for decryption.

        Returns:
            bytes: The decrypted payload of the Join Accept message.
        &#34;&#34;&#34;
        payload = packet[4:-2]  # remove chcksum
        cipher = AES.new(appkey, AES.MODE_ECB)
        return cipher.encrypt(payload)

    def encrypt_join_accept(self, packet, appkey):
        &#34;&#34;&#34;Encrypts a Join Accept message using the provided AppKey.

        This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It decrypts the payload using AES in ECB mode with the AppKey and returns the decrypted message (without checksum).

        Args:
            packet (bytes): The LoRaWAN Join Accept message to encrypt.
            appkey (bytes): The AppKey used for encryption.

        Returns:
            bytes: The encrypted payload of the Join Accept message (without checksum).
        &#34;&#34;&#34;
        payload = packet[4:]
        cipher = AES.new(appkey, AES.MODE_ECB)
        return cipher.decrypt(payload)

    def __hex_to_bytes(hex_string):
        return binascii.unhexlify(hex_string)

    def __aes_encrypt(self, app_key, control_byte, app_nonce, net_id, dev_nonce):
        &#34;&#34;&#34;Encrypts data using AES in ECB mode with the AppKey.

        This internal helper function takes the AppKey, control byte, AppNonce, NetID, and DevNonce as arguments. It constructs a data block, encrypts it using AES in ECB mode with the AppKey, and returns the encrypted data in hexadecimal format.

        Args:
            app_key (bytes): The AppKey used for encryption.
            control_byte (int): The control byte for the operation.
            app_nonce (str): The AppNonce value (hexadecimal string).
            net_id (str): The NetID value (hexadecimal string).
            dev_nonce (str): The DevNonce value (hexadecimal string).

        Returns:
            str: The encrypted data in hexadecimal format.
        &#34;&#34;&#34;
        key_bytes = self.hex_to_bytes(app_key)
        control_byte_bytes = bytes([control_byte])
        app_nonce_bytes = self.hex_to_bytes(app_nonce)
        net_id_bytes = self.hex_to_bytes(net_id)
        dev_nonce_bytes = self.hex_to_bytes(dev_nonce)

        data = control_byte_bytes + app_nonce_bytes + net_id_bytes + dev_nonce_bytes
        cipher = AES.new(key_bytes, AES.MODE_ECB)
        encrypted = cipher.encrypt(data)

        return binascii.hexlify(encrypted).decode()



    def derive_session_keys(self, app_key, nwk_key, join_eui, app_nonce, net_id, dev_nonce):
        &#34;&#34;&#34;Derives session keys for LoRaWAN communication.

        This function takes the AppKey, NwkKey (assumed to be the same as AppKey for LoRaWANv1.0), JoinEUI, AppNonce, NetID, and DevNonce as arguments. It uses the `aes_encrypt` helper function to derive the following session keys:
            - NwkSKey
            - AppSKey
            - FNwkSIntKey
            - SNwkSIntKey
            - NwkSEncKey

        Args:
            app_key (bytes): The AppKey used for key derivation.
            nwk_key (bytes): The NwkKey (assumed to be the same as AppKey for LoRaWANv1.0).
            join_eui (str): The JoinEUI value (hexadecimal string).
            app_nonce (str): The AppNonce value (hexadecimal string).
            net_id (str): The NetID value (hexadecimal string).
            dev_nonce (str): The DevNonce value (hexadecimal string).

        Returns:
            tuple: A tuple containing the derived session keys (NwkSKey, AppSKey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey).
        &#34;&#34;&#34;
        &#34;&#34;&#34;AppNonce is equivalent to the JoinNonce. In case of LoRaWANv1.0, the app_key and nwk_key are the same, as well as AppEUI and JoinEUI&#34;&#34;&#34;
        nwk_skey = self.aes_encrypt(app_key, 0x01, app_nonce, net_id, dev_nonce)
        app_skey = self.aes_encrypt(app_key, 0x02, app_nonce, net_id, dev_nonce)

        FNwkSIntKey = self.aes_encrypt(nwk_key, 0x01, app_nonce, join_eui, dev_nonce)
        SNwkSIntKey = self.aes_encrypt(nwk_key, 0x03, app_nonce, join_eui, dev_nonce)
        NwkSEncKey = self.aes_encrypt(nwk_key, 0x04, app_nonce, join_eui, dev_nonce)

        return nwk_skey, app_skey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey

    def compute_MIC(self, key, data):
        &#34;&#34;&#34;Computes the Message Integrity Check (MIC) for a message.

        This function takes a key (bytes) and data (bytes) as arguments. It uses the CMAC function with AES as the underlying cipher to compute the MIC value for the provided data. The MIC value is returned as a hexadecimal string representing the first 8 bytes of the CMAC output.

        Args:
            key (bytes): The secret key used for MIC calculation.
            data (bytes): The data for which the MIC needs to be computed.

        Returns:
            str: The MIC value for the data in hexadecimal format (first 8 bytes of CMAC output).
        &#34;&#34;&#34;
        cobj = CMAC.new(key, ciphermod=AES)
        res = cobj.update(data).hexdigest()
        return res[0:8]

    def __to_bytes(self, s):
        if sys.version_info &lt; (3,):
            return &#34;&#34;.join(map(chr, s))
        else:
            return bytes(s)

    def FRMPayload_decrypt(self, payload_hex, sequence_counter, key, dev_addr, direction=0):
        &#34;&#34;&#34;
        Source: https://github.com/jieter/python-lora/blob/master/lora/crypto.py#L54

        LoraMac decrypt

        Which is actually encrypting a predefined 16-byte block (ref LoraWAN
        specification 4.3.3.1) and XORing that with each block of data.

        payload_hex: hex-encoded payload (FRMPayload)
        sequence_counter: integer, sequence counter (FCntUp)
        key: 16-byte hex-encoded AES key. (i.e. AABBCCDDEEFFAABBCCDDEEFFAABBCCDD)
        dev_addr: 4-byte hex-encoded DevAddr (i.e. AABBCCDD)
        direction: 0 for uplink packets, 1 for downlink packets

        returns an array of byte values.

        This method is based on `void LoRaMacPayloadEncrypt()` in
        https://github.com/Lora-net/LoRaMac-node/blob/master/src/mac/LoRaMacCrypto.c#L108
        &#34;&#34;&#34;
        key = unhexlify(key)
        dev_addr = unhexlify(dev_addr)
        buffer = bytearray(unhexlify(payload_hex))
        size = len(buffer)

        bufferIndex = 0
        # block counter
        ctr = 1

        # output buffer, initialize to input buffer size.
        encBuffer = [0x00] * size

        cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())

        def aes_encrypt_block(aBlock):
            &#34;&#34;&#34;
            AES encrypt a block.
            aes.encrypt expects a string, so we convert the input to string and
            the return value to bytes again.
            &#34;&#34;&#34;
            encryptor = cipher.encryptor()

            return bytearray(encryptor.update(self.__to_bytes(aBlock)) + encryptor.finalize())

        # For the exact definition of this block refer to
        # &#39;chapter 4.3.3.1 Encryption in LoRaWAN&#39; in the LoRaWAN specification
        aBlock = bytearray(
            [
                0x01,  # 0 always 0x01
                0x00,  # 1 always 0x00
                0x00,  # 2 always 0x00
                0x00,  # 3 always 0x00
                0x00,  # 4 always 0x00
                direction,  # 5 dir, 0 for uplink, 1 for downlink
                dev_addr[3],  # 6 devaddr, lsb
                dev_addr[2],  # 7 devaddr
                dev_addr[1],  # 8 devaddr
                dev_addr[0],  # 9 devaddr, msb
                sequence_counter &amp; 0xFF,  # 10 sequence counter (FCntUp) lsb
                (sequence_counter &gt;&gt; 8) &amp; 0xFF,  # 11 sequence counter
                (sequence_counter &gt;&gt; 16) &amp; 0xFF,  # 12 sequence counter
                (sequence_counter &gt;&gt; 24) &amp; 0xFF,  # 13 sequence counter (FCntUp) msb
                0x00,  # 14 always 0x01
                0x00,  # 15 block counter
            ]
        )

        # complete blocks
        while size &gt;= 16:
            aBlock[15] = ctr &amp; 0xFF
            ctr += 1
            sBlock = aes_encrypt_block(aBlock)
            for i in range(16):
                encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i]

            size -= 16
            bufferIndex += 16

        # partial blocks
        if size &gt; 0:
            aBlock[15] = ctr &amp; 0xFF
            sBlock = aes_encrypt_block(aBlock)
            for i in range(size):
                encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i]

        return encBuffer


if __name__ == &#34;__main__&#34;:
    c = CryptoTool()
    pt = c.FRMPayload_decrypt(&#39;247D22681F66D35B67AD93B3FE&#39;, 0x22, &#39;C1076C63B971710A708E3471A7C803D7&#39;, &#39;260b4ede&#39;, 0)
    print(pt)
    print(bytes(pt).hex())
    print(bytes(pt).decode(&#39;iso-8859-1&#39;))
    print(bytes.fromhex(&#39;18311040de4e0b2680080001b7bdb6a97da328f44fe5ece3d71f063920&#39;)[3:-4])
    mic = c.compute_MIC(bytes.fromhex(&#39;C1076C63B971710A708E3471A7C803D7&#39;),bytes.fromhex(&#39;40de4e0b2680080001b7bdb6a97da328f44fe5ece3d7&#39;))
    print(mic)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.crypto_tools.CryptoTool"><code class="flex name class">
<span>class <span class="ident">CryptoTool</span></span>
</code></dt>
<dd>
<div class="desc"><p>Cryptographic toolset for LoRaWAN security operations.</p>
<p>This class provides functionalities for encryption, decryption, key derivation, and message integrity checking (MIC) used in LoRaWAN communication. It supports operations on Join Accept messages, session key derivation, and FRMPayload encryption/decryption for both uplink and downlink directions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CryptoTool():
    &#34;&#34;&#34;Cryptographic toolset for LoRaWAN security operations.

    This class provides functionalities for encryption, decryption, key derivation, and message integrity checking (MIC) used in LoRaWAN communication. It supports operations on Join Accept messages, session key derivation, and FRMPayload encryption/decryption for both uplink and downlink directions.
    &#34;&#34;&#34;
    def decrypt_join_accept(self, packet, appkey):
        &#34;&#34;&#34;Decrypts a Join Accept message using the provided AppKey.

        This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It removes the checksum and decrypts the payload using AES in ECB mode with the AppKey.

        Args:
            packet (bytes): The LoRaWAN Join Accept message to decrypt.
            appkey (bytes): The AppKey used for decryption.

        Returns:
            bytes: The decrypted payload of the Join Accept message.
        &#34;&#34;&#34;
        payload = packet[4:-2]  # remove chcksum
        cipher = AES.new(appkey, AES.MODE_ECB)
        return cipher.encrypt(payload)

    def encrypt_join_accept(self, packet, appkey):
        &#34;&#34;&#34;Encrypts a Join Accept message using the provided AppKey.

        This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It decrypts the payload using AES in ECB mode with the AppKey and returns the decrypted message (without checksum).

        Args:
            packet (bytes): The LoRaWAN Join Accept message to encrypt.
            appkey (bytes): The AppKey used for encryption.

        Returns:
            bytes: The encrypted payload of the Join Accept message (without checksum).
        &#34;&#34;&#34;
        payload = packet[4:]
        cipher = AES.new(appkey, AES.MODE_ECB)
        return cipher.decrypt(payload)

    def __hex_to_bytes(hex_string):
        return binascii.unhexlify(hex_string)

    def __aes_encrypt(self, app_key, control_byte, app_nonce, net_id, dev_nonce):
        &#34;&#34;&#34;Encrypts data using AES in ECB mode with the AppKey.

        This internal helper function takes the AppKey, control byte, AppNonce, NetID, and DevNonce as arguments. It constructs a data block, encrypts it using AES in ECB mode with the AppKey, and returns the encrypted data in hexadecimal format.

        Args:
            app_key (bytes): The AppKey used for encryption.
            control_byte (int): The control byte for the operation.
            app_nonce (str): The AppNonce value (hexadecimal string).
            net_id (str): The NetID value (hexadecimal string).
            dev_nonce (str): The DevNonce value (hexadecimal string).

        Returns:
            str: The encrypted data in hexadecimal format.
        &#34;&#34;&#34;
        key_bytes = self.hex_to_bytes(app_key)
        control_byte_bytes = bytes([control_byte])
        app_nonce_bytes = self.hex_to_bytes(app_nonce)
        net_id_bytes = self.hex_to_bytes(net_id)
        dev_nonce_bytes = self.hex_to_bytes(dev_nonce)

        data = control_byte_bytes + app_nonce_bytes + net_id_bytes + dev_nonce_bytes
        cipher = AES.new(key_bytes, AES.MODE_ECB)
        encrypted = cipher.encrypt(data)

        return binascii.hexlify(encrypted).decode()



    def derive_session_keys(self, app_key, nwk_key, join_eui, app_nonce, net_id, dev_nonce):
        &#34;&#34;&#34;Derives session keys for LoRaWAN communication.

        This function takes the AppKey, NwkKey (assumed to be the same as AppKey for LoRaWANv1.0), JoinEUI, AppNonce, NetID, and DevNonce as arguments. It uses the `aes_encrypt` helper function to derive the following session keys:
            - NwkSKey
            - AppSKey
            - FNwkSIntKey
            - SNwkSIntKey
            - NwkSEncKey

        Args:
            app_key (bytes): The AppKey used for key derivation.
            nwk_key (bytes): The NwkKey (assumed to be the same as AppKey for LoRaWANv1.0).
            join_eui (str): The JoinEUI value (hexadecimal string).
            app_nonce (str): The AppNonce value (hexadecimal string).
            net_id (str): The NetID value (hexadecimal string).
            dev_nonce (str): The DevNonce value (hexadecimal string).

        Returns:
            tuple: A tuple containing the derived session keys (NwkSKey, AppSKey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey).
        &#34;&#34;&#34;
        &#34;&#34;&#34;AppNonce is equivalent to the JoinNonce. In case of LoRaWANv1.0, the app_key and nwk_key are the same, as well as AppEUI and JoinEUI&#34;&#34;&#34;
        nwk_skey = self.aes_encrypt(app_key, 0x01, app_nonce, net_id, dev_nonce)
        app_skey = self.aes_encrypt(app_key, 0x02, app_nonce, net_id, dev_nonce)

        FNwkSIntKey = self.aes_encrypt(nwk_key, 0x01, app_nonce, join_eui, dev_nonce)
        SNwkSIntKey = self.aes_encrypt(nwk_key, 0x03, app_nonce, join_eui, dev_nonce)
        NwkSEncKey = self.aes_encrypt(nwk_key, 0x04, app_nonce, join_eui, dev_nonce)

        return nwk_skey, app_skey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey

    def compute_MIC(self, key, data):
        &#34;&#34;&#34;Computes the Message Integrity Check (MIC) for a message.

        This function takes a key (bytes) and data (bytes) as arguments. It uses the CMAC function with AES as the underlying cipher to compute the MIC value for the provided data. The MIC value is returned as a hexadecimal string representing the first 8 bytes of the CMAC output.

        Args:
            key (bytes): The secret key used for MIC calculation.
            data (bytes): The data for which the MIC needs to be computed.

        Returns:
            str: The MIC value for the data in hexadecimal format (first 8 bytes of CMAC output).
        &#34;&#34;&#34;
        cobj = CMAC.new(key, ciphermod=AES)
        res = cobj.update(data).hexdigest()
        return res[0:8]

    def __to_bytes(self, s):
        if sys.version_info &lt; (3,):
            return &#34;&#34;.join(map(chr, s))
        else:
            return bytes(s)

    def FRMPayload_decrypt(self, payload_hex, sequence_counter, key, dev_addr, direction=0):
        &#34;&#34;&#34;
        Source: https://github.com/jieter/python-lora/blob/master/lora/crypto.py#L54

        LoraMac decrypt

        Which is actually encrypting a predefined 16-byte block (ref LoraWAN
        specification 4.3.3.1) and XORing that with each block of data.

        payload_hex: hex-encoded payload (FRMPayload)
        sequence_counter: integer, sequence counter (FCntUp)
        key: 16-byte hex-encoded AES key. (i.e. AABBCCDDEEFFAABBCCDDEEFFAABBCCDD)
        dev_addr: 4-byte hex-encoded DevAddr (i.e. AABBCCDD)
        direction: 0 for uplink packets, 1 for downlink packets

        returns an array of byte values.

        This method is based on `void LoRaMacPayloadEncrypt()` in
        https://github.com/Lora-net/LoRaMac-node/blob/master/src/mac/LoRaMacCrypto.c#L108
        &#34;&#34;&#34;
        key = unhexlify(key)
        dev_addr = unhexlify(dev_addr)
        buffer = bytearray(unhexlify(payload_hex))
        size = len(buffer)

        bufferIndex = 0
        # block counter
        ctr = 1

        # output buffer, initialize to input buffer size.
        encBuffer = [0x00] * size

        cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())

        def aes_encrypt_block(aBlock):
            &#34;&#34;&#34;
            AES encrypt a block.
            aes.encrypt expects a string, so we convert the input to string and
            the return value to bytes again.
            &#34;&#34;&#34;
            encryptor = cipher.encryptor()

            return bytearray(encryptor.update(self.__to_bytes(aBlock)) + encryptor.finalize())

        # For the exact definition of this block refer to
        # &#39;chapter 4.3.3.1 Encryption in LoRaWAN&#39; in the LoRaWAN specification
        aBlock = bytearray(
            [
                0x01,  # 0 always 0x01
                0x00,  # 1 always 0x00
                0x00,  # 2 always 0x00
                0x00,  # 3 always 0x00
                0x00,  # 4 always 0x00
                direction,  # 5 dir, 0 for uplink, 1 for downlink
                dev_addr[3],  # 6 devaddr, lsb
                dev_addr[2],  # 7 devaddr
                dev_addr[1],  # 8 devaddr
                dev_addr[0],  # 9 devaddr, msb
                sequence_counter &amp; 0xFF,  # 10 sequence counter (FCntUp) lsb
                (sequence_counter &gt;&gt; 8) &amp; 0xFF,  # 11 sequence counter
                (sequence_counter &gt;&gt; 16) &amp; 0xFF,  # 12 sequence counter
                (sequence_counter &gt;&gt; 24) &amp; 0xFF,  # 13 sequence counter (FCntUp) msb
                0x00,  # 14 always 0x01
                0x00,  # 15 block counter
            ]
        )

        # complete blocks
        while size &gt;= 16:
            aBlock[15] = ctr &amp; 0xFF
            ctr += 1
            sBlock = aes_encrypt_block(aBlock)
            for i in range(16):
                encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i]

            size -= 16
            bufferIndex += 16

        # partial blocks
        if size &gt; 0:
            aBlock[15] = ctr &amp; 0xFF
            sBlock = aes_encrypt_block(aBlock)
            for i in range(size):
                encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i]

        return encBuffer</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.crypto_tools.CryptoTool.FRMPayload_decrypt"><code class="name flex">
<span>def <span class="ident">FRMPayload_decrypt</span></span>(<span>self, payload_hex, sequence_counter, key, dev_addr, direction=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Source: <a href="https://github.com/jieter/python-lora/blob/master/lora/crypto.py#L54">https://github.com/jieter/python-lora/blob/master/lora/crypto.py#L54</a></p>
<p>LoraMac decrypt</p>
<p>Which is actually encrypting a predefined 16-byte block (ref LoraWAN
specification 4.3.3.1) and XORing that with each block of data.</p>
<p>payload_hex: hex-encoded payload (FRMPayload)
sequence_counter: integer, sequence counter (FCntUp)
key: 16-byte hex-encoded AES key. (i.e. AABBCCDDEEFFAABBCCDDEEFFAABBCCDD)
dev_addr: 4-byte hex-encoded DevAddr (i.e. AABBCCDD)
direction: 0 for uplink packets, 1 for downlink packets</p>
<p>returns an array of byte values.</p>
<p>This method is based on <code>void LoRaMacPayloadEncrypt()</code> in
<a href="https://github.com/Lora-net/LoRaMac-node/blob/master/src/mac/LoRaMacCrypto.c#L108">https://github.com/Lora-net/LoRaMac-node/blob/master/src/mac/LoRaMacCrypto.c#L108</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FRMPayload_decrypt(self, payload_hex, sequence_counter, key, dev_addr, direction=0):
    &#34;&#34;&#34;
    Source: https://github.com/jieter/python-lora/blob/master/lora/crypto.py#L54

    LoraMac decrypt

    Which is actually encrypting a predefined 16-byte block (ref LoraWAN
    specification 4.3.3.1) and XORing that with each block of data.

    payload_hex: hex-encoded payload (FRMPayload)
    sequence_counter: integer, sequence counter (FCntUp)
    key: 16-byte hex-encoded AES key. (i.e. AABBCCDDEEFFAABBCCDDEEFFAABBCCDD)
    dev_addr: 4-byte hex-encoded DevAddr (i.e. AABBCCDD)
    direction: 0 for uplink packets, 1 for downlink packets

    returns an array of byte values.

    This method is based on `void LoRaMacPayloadEncrypt()` in
    https://github.com/Lora-net/LoRaMac-node/blob/master/src/mac/LoRaMacCrypto.c#L108
    &#34;&#34;&#34;
    key = unhexlify(key)
    dev_addr = unhexlify(dev_addr)
    buffer = bytearray(unhexlify(payload_hex))
    size = len(buffer)

    bufferIndex = 0
    # block counter
    ctr = 1

    # output buffer, initialize to input buffer size.
    encBuffer = [0x00] * size

    cipher = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend())

    def aes_encrypt_block(aBlock):
        &#34;&#34;&#34;
        AES encrypt a block.
        aes.encrypt expects a string, so we convert the input to string and
        the return value to bytes again.
        &#34;&#34;&#34;
        encryptor = cipher.encryptor()

        return bytearray(encryptor.update(self.__to_bytes(aBlock)) + encryptor.finalize())

    # For the exact definition of this block refer to
    # &#39;chapter 4.3.3.1 Encryption in LoRaWAN&#39; in the LoRaWAN specification
    aBlock = bytearray(
        [
            0x01,  # 0 always 0x01
            0x00,  # 1 always 0x00
            0x00,  # 2 always 0x00
            0x00,  # 3 always 0x00
            0x00,  # 4 always 0x00
            direction,  # 5 dir, 0 for uplink, 1 for downlink
            dev_addr[3],  # 6 devaddr, lsb
            dev_addr[2],  # 7 devaddr
            dev_addr[1],  # 8 devaddr
            dev_addr[0],  # 9 devaddr, msb
            sequence_counter &amp; 0xFF,  # 10 sequence counter (FCntUp) lsb
            (sequence_counter &gt;&gt; 8) &amp; 0xFF,  # 11 sequence counter
            (sequence_counter &gt;&gt; 16) &amp; 0xFF,  # 12 sequence counter
            (sequence_counter &gt;&gt; 24) &amp; 0xFF,  # 13 sequence counter (FCntUp) msb
            0x00,  # 14 always 0x01
            0x00,  # 15 block counter
        ]
    )

    # complete blocks
    while size &gt;= 16:
        aBlock[15] = ctr &amp; 0xFF
        ctr += 1
        sBlock = aes_encrypt_block(aBlock)
        for i in range(16):
            encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i]

        size -= 16
        bufferIndex += 16

    # partial blocks
    if size &gt; 0:
        aBlock[15] = ctr &amp; 0xFF
        sBlock = aes_encrypt_block(aBlock)
        for i in range(size):
            encBuffer[bufferIndex + i] = buffer[bufferIndex + i] ^ sBlock[i]

    return encBuffer</code></pre>
</details>
</dd>
<dt id="src.crypto_tools.CryptoTool.compute_MIC"><code class="name flex">
<span>def <span class="ident">compute_MIC</span></span>(<span>self, key, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the Message Integrity Check (MIC) for a message.</p>
<p>This function takes a key (bytes) and data (bytes) as arguments. It uses the CMAC function with AES as the underlying cipher to compute the MIC value for the provided data. The MIC value is returned as a hexadecimal string representing the first 8 bytes of the CMAC output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The secret key used for MIC calculation.</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The data for which the MIC needs to be computed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The MIC value for the data in hexadecimal format (first 8 bytes of CMAC output).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_MIC(self, key, data):
    &#34;&#34;&#34;Computes the Message Integrity Check (MIC) for a message.

    This function takes a key (bytes) and data (bytes) as arguments. It uses the CMAC function with AES as the underlying cipher to compute the MIC value for the provided data. The MIC value is returned as a hexadecimal string representing the first 8 bytes of the CMAC output.

    Args:
        key (bytes): The secret key used for MIC calculation.
        data (bytes): The data for which the MIC needs to be computed.

    Returns:
        str: The MIC value for the data in hexadecimal format (first 8 bytes of CMAC output).
    &#34;&#34;&#34;
    cobj = CMAC.new(key, ciphermod=AES)
    res = cobj.update(data).hexdigest()
    return res[0:8]</code></pre>
</details>
</dd>
<dt id="src.crypto_tools.CryptoTool.decrypt_join_accept"><code class="name flex">
<span>def <span class="ident">decrypt_join_accept</span></span>(<span>self, packet, appkey)</span>
</code></dt>
<dd>
<div class="desc"><p>Decrypts a Join Accept message using the provided AppKey.</p>
<p>This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It removes the checksum and decrypts the payload using AES in ECB mode with the AppKey.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packet</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The LoRaWAN Join Accept message to decrypt.</dd>
<dt><strong><code>appkey</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The AppKey used for decryption.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The decrypted payload of the Join Accept message.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_join_accept(self, packet, appkey):
    &#34;&#34;&#34;Decrypts a Join Accept message using the provided AppKey.

    This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It removes the checksum and decrypts the payload using AES in ECB mode with the AppKey.

    Args:
        packet (bytes): The LoRaWAN Join Accept message to decrypt.
        appkey (bytes): The AppKey used for decryption.

    Returns:
        bytes: The decrypted payload of the Join Accept message.
    &#34;&#34;&#34;
    payload = packet[4:-2]  # remove chcksum
    cipher = AES.new(appkey, AES.MODE_ECB)
    return cipher.encrypt(payload)</code></pre>
</details>
</dd>
<dt id="src.crypto_tools.CryptoTool.derive_session_keys"><code class="name flex">
<span>def <span class="ident">derive_session_keys</span></span>(<span>self, app_key, nwk_key, join_eui, app_nonce, net_id, dev_nonce)</span>
</code></dt>
<dd>
<div class="desc"><p>Derives session keys for LoRaWAN communication.</p>
<p>This function takes the AppKey, NwkKey (assumed to be the same as AppKey for LoRaWANv1.0), JoinEUI, AppNonce, NetID, and DevNonce as arguments. It uses the <code>aes_encrypt</code> helper function to derive the following session keys:
- NwkSKey
- AppSKey
- FNwkSIntKey
- SNwkSIntKey
- NwkSEncKey</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app_key</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The AppKey used for key derivation.</dd>
<dt><strong><code>nwk_key</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The NwkKey (assumed to be the same as AppKey for LoRaWANv1.0).</dd>
<dt><strong><code>join_eui</code></strong> :&ensp;<code>str</code></dt>
<dd>The JoinEUI value (hexadecimal string).</dd>
<dt><strong><code>app_nonce</code></strong> :&ensp;<code>str</code></dt>
<dd>The AppNonce value (hexadecimal string).</dd>
<dt><strong><code>net_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The NetID value (hexadecimal string).</dd>
<dt><strong><code>dev_nonce</code></strong> :&ensp;<code>str</code></dt>
<dd>The DevNonce value (hexadecimal string).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing the derived session keys (NwkSKey, AppSKey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derive_session_keys(self, app_key, nwk_key, join_eui, app_nonce, net_id, dev_nonce):
    &#34;&#34;&#34;Derives session keys for LoRaWAN communication.

    This function takes the AppKey, NwkKey (assumed to be the same as AppKey for LoRaWANv1.0), JoinEUI, AppNonce, NetID, and DevNonce as arguments. It uses the `aes_encrypt` helper function to derive the following session keys:
        - NwkSKey
        - AppSKey
        - FNwkSIntKey
        - SNwkSIntKey
        - NwkSEncKey

    Args:
        app_key (bytes): The AppKey used for key derivation.
        nwk_key (bytes): The NwkKey (assumed to be the same as AppKey for LoRaWANv1.0).
        join_eui (str): The JoinEUI value (hexadecimal string).
        app_nonce (str): The AppNonce value (hexadecimal string).
        net_id (str): The NetID value (hexadecimal string).
        dev_nonce (str): The DevNonce value (hexadecimal string).

    Returns:
        tuple: A tuple containing the derived session keys (NwkSKey, AppSKey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey).
    &#34;&#34;&#34;
    &#34;&#34;&#34;AppNonce is equivalent to the JoinNonce. In case of LoRaWANv1.0, the app_key and nwk_key are the same, as well as AppEUI and JoinEUI&#34;&#34;&#34;
    nwk_skey = self.aes_encrypt(app_key, 0x01, app_nonce, net_id, dev_nonce)
    app_skey = self.aes_encrypt(app_key, 0x02, app_nonce, net_id, dev_nonce)

    FNwkSIntKey = self.aes_encrypt(nwk_key, 0x01, app_nonce, join_eui, dev_nonce)
    SNwkSIntKey = self.aes_encrypt(nwk_key, 0x03, app_nonce, join_eui, dev_nonce)
    NwkSEncKey = self.aes_encrypt(nwk_key, 0x04, app_nonce, join_eui, dev_nonce)

    return nwk_skey, app_skey, FNwkSIntKey, SNwkSIntKey, NwkSEncKey</code></pre>
</details>
</dd>
<dt id="src.crypto_tools.CryptoTool.encrypt_join_accept"><code class="name flex">
<span>def <span class="ident">encrypt_join_accept</span></span>(<span>self, packet, appkey)</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypts a Join Accept message using the provided AppKey.</p>
<p>This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It decrypts the payload using AES in ECB mode with the AppKey and returns the decrypted message (without checksum).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>packet</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The LoRaWAN Join Accept message to encrypt.</dd>
<dt><strong><code>appkey</code></strong> :&ensp;<code>bytes</code></dt>
<dd>The AppKey used for encryption.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>The encrypted payload of the Join Accept message (without checksum).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_join_accept(self, packet, appkey):
    &#34;&#34;&#34;Encrypts a Join Accept message using the provided AppKey.

    This function takes a LoRaWAN Join Accept message (bytes) and the AppKey (bytes) as arguments. It decrypts the payload using AES in ECB mode with the AppKey and returns the decrypted message (without checksum).

    Args:
        packet (bytes): The LoRaWAN Join Accept message to encrypt.
        appkey (bytes): The AppKey used for encryption.

    Returns:
        bytes: The encrypted payload of the Join Accept message (without checksum).
    &#34;&#34;&#34;
    payload = packet[4:]
    cipher = AES.new(appkey, AES.MODE_ECB)
    return cipher.decrypt(payload)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src" href="index.html">src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.crypto_tools.CryptoTool" href="#src.crypto_tools.CryptoTool">CryptoTool</a></code></h4>
<ul class="">
<li><code><a title="src.crypto_tools.CryptoTool.FRMPayload_decrypt" href="#src.crypto_tools.CryptoTool.FRMPayload_decrypt">FRMPayload_decrypt</a></code></li>
<li><code><a title="src.crypto_tools.CryptoTool.compute_MIC" href="#src.crypto_tools.CryptoTool.compute_MIC">compute_MIC</a></code></li>
<li><code><a title="src.crypto_tools.CryptoTool.decrypt_join_accept" href="#src.crypto_tools.CryptoTool.decrypt_join_accept">decrypt_join_accept</a></code></li>
<li><code><a title="src.crypto_tools.CryptoTool.derive_session_keys" href="#src.crypto_tools.CryptoTool.derive_session_keys">derive_session_keys</a></code></li>
<li><code><a title="src.crypto_tools.CryptoTool.encrypt_join_accept" href="#src.crypto_tools.CryptoTool.encrypt_join_accept">encrypt_join_accept</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>